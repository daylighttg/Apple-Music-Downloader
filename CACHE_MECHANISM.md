# 缓存中转机制说明

## 概述

缓存中转机制是一个旨在优化下载性能和稳定性的功能，特别适用于目标路径为NFS等网络文件系统的场景。

## 工作原理

1. **本地缓存**: 数据首先下载到本地Cache文件夹（默认在当前目录下的`./Cache`）
2. **本地处理**: 所有的解密、合并、元数据封装等操作都在本地缓存中完成
3. **批量传输**: 完成所有处理后，将整个专辑/播放列表一次性移动到最终的NFS目标路径
4. **自动清理**: 成功传输后自动清理缓存；失败时也会清理临时文件

## 优势

### 性能提升
- **减少网络I/O**: 避免频繁的小文件网络读写操作
- **提升处理速度**: 本地磁盘I/O远快于网络文件系统
- **降低延迟**: 减少网络往返时间

### 稳定性增强
- **避免网络中断**: 即使网络临时中断，本地处理不受影响
- **原子性操作**: 只有完全处理完成后才移动到目标位置
- **失败恢复**: 出错时自动清理，不会留下不完整的文件

### NFS优化
- **减轻NFS负载**: 大幅减少NFS服务器的请求次数
- **避免元数据风暴**: 不在NFS上频繁创建/修改小文件
- **提升并发性能**: 多个下载任务不会互相干扰NFS性能

## 配置方法

在 `config.yaml` 中添加以下配置：

```yaml
# 缓存中转机制设置
enable-cache: true              # 是否启用缓存机制 (true/false)
cache-folder: "./Cache"         # 缓存文件夹路径，相对路径或绝对路径
```

### 配置选项说明

#### enable-cache
- **类型**: 布尔值 (true/false)
- **默认值**: false
- **说明**: 是否启用缓存中转机制
- **建议**: 如果目标路径是NFS等网络文件系统，强烈建议设置为 `true`

#### cache-folder
- **类型**: 字符串
- **默认值**: "./Cache"
- **说明**: 缓存文件夹的路径
- **支持**: 相对路径或绝对路径
- **建议**: 
  - 使用SSD等高速本地磁盘
  - 确保有足够的磁盘空间（建议预留50GB以上）
  - 不要设置在NFS等网络路径上

## 使用示例

### 示例1: 基本配置
```yaml
enable-cache: true
cache-folder: "./Cache"
alac-save-folder: "/media/Music/AppleMusic/Alac"    # NFS路径
atmos-save-folder: "/media/Music/AppleMusic/Atmos"  # NFS路径
```

### 示例2: 自定义缓存路径
```yaml
enable-cache: true
cache-folder: "/tmp/apple-music-cache"  # 使用系统临时目录
alac-save-folder: "/mnt/nfs/Music/Alac"
```

### 示例3: SSD缓存路径
```yaml
enable-cache: true
cache-folder: "/ssd/cache/apple-music"  # 使用SSD作为缓存
alac-save-folder: "/nas/Music/Alac"     # NAS存储
```

## 工作流程详解

### 下载专辑时

1. **初始化**
   - 程序检测到启用了缓存机制
   - 在Cache文件夹下创建唯一的子目录（基于专辑ID的hash值）

2. **下载阶段**
   ```
   Cache/
   └── [hash值]/
       └── [艺术家名]/
           └── [专辑名]/
               ├── cover.jpg
               ├── 01. Song1.m4a
               ├── 02. Song2.m4a
               └── ...
   ```

3. **处理阶段**
   - 解密: 在本地Cache中进行
   - 合并: 在本地Cache中进行
   - 元数据封装: 在本地Cache中进行
   - 歌词嵌入: 在本地Cache中进行

4. **传输阶段**
   - 所有track处理完成后
   - 显示 "正在从缓存转移文件到目标位置..."
   - 将整个专辑文件夹移动到NFS目标路径
   - 清理Cache文件夹

5. **完成**
   ```
   /media/Music/AppleMusic/Alac/
   └── [艺术家名]/
       └── [专辑名]/
           ├── cover.jpg
           ├── 01. Song1.m4a
           ├── 02. Song2.m4a
           └── ...
   ```

### 错误处理

如果在任何阶段出错：
- 自动清理Cache中的临时文件
- 不会在目标位置留下不完整的文件
- 记录错误信息供排查

## 注意事项

### 磁盘空间
- Cache文件夹需要有足够的空间存储临时文件
- 建议预留至少50GB空间（取决于下载的内容）
- 可以定期手动清理Cache文件夹（程序会自动创建）

### 性能考虑
- **最佳实践**: Cache文件夹放在SSD上，目标路径为NFS
- **避免**: Cache文件夹和目标路径在同一个慢速网络文件系统上

### 安全性
- 程序会在失败时自动清理缓存
- 不会删除目标位置的已有文件
- 使用原子性操作确保数据一致性

### 跨文件系统
- 如果Cache和目标路径在不同文件系统，会使用拷贝+删除的方式
- 这是安全的，但比同文件系统的重命名操作慢一些

## 性能对比

### 未启用缓存 (直接写入NFS)
```
下载Track1 -> 写入NFS -> 解密 -> 写入NFS -> 封装元数据 -> 写入NFS
下载Track2 -> 写入NFS -> 解密 -> 写入NFS -> 封装元数据 -> 写入NFS
...
总时间: 约 5-10分钟 (取决于网络延迟和NFS性能)
网络请求: 数百次小文件操作
```

### 启用缓存 (本地处理后批量传输)
```
下载Track1 -> 本地处理 -> 内存/本地磁盘
下载Track2 -> 本地处理 -> 内存/本地磁盘
...
批量传输 -> NFS (一次性操作)
总时间: 约 2-3分钟 (大幅减少网络等待时间)
网络请求: 一次批量传输
```

**性能提升**: 通常可提升 50%-70% 的整体速度

## 故障排查

### 问题1: "创建缓存目录失败"
**原因**: 没有权限或路径不存在
**解决**: 
- 检查cache-folder路径是否正确
- 确保程序有写权限
- 尝试使用绝对路径

### 问题2: "从缓存移动文件失败"
**原因**: 目标路径权限不足或磁盘已满
**解决**:
- 检查目标路径的写权限
- 检查目标路径的磁盘空间
- 检查NFS连接是否正常

### 问题3: Cache文件夹占用空间很大
**原因**: 之前失败的任务没有清理
**解决**:
- 手动删除Cache文件夹: `rm -rf ./Cache`
- 程序会在下次运行时自动重建

### 问题4: 性能提升不明显
**原因**: Cache路径配置不当
**检查**:
- Cache路径是否在本地快速磁盘上
- 不要将Cache路径设置在NFS等网络路径上
- 考虑使用SSD作为缓存

## 高级配置

### 多任务并行下载
```yaml
enable-cache: true
cache-folder: "./Cache"
txtDownloadThreads: 5  # 同时下载5个专辑

# 每个专辑会在Cache下有独立的子目录
# 不会互相干扰
```

### 大型音乐库迁移
```yaml
enable-cache: true
cache-folder: "/ssd/large-cache"  # 使用大容量SSD
alac-save-folder: "/nas/production/Music/Alac"
```

## 技术实现

### 文件移动策略
1. **同文件系统**: 使用 `os.Rename()` 原子操作
2. **跨文件系统**: 使用 `io.Copy()` + `os.Remove()` 安全拷贝

### 缓存目录结构
```
Cache/
├── [hash1]/  # 专辑1的临时目录
│   └── ...
├── [hash2]/  # 专辑2的临时目录
│   └── ...
└── ...
```

每个专辑使用独立的hash目录，避免冲突

### 清理机制
- 成功: 传输完成后立即清理对应的hash目录
- 失败: defer函数确保即使出错也会清理
- 手动: 可以随时手动删除整个Cache文件夹

## 总结

缓存中转机制是针对NFS等网络文件系统优化的重要功能，通过本地缓存和批量传输的方式，显著提升下载效率和稳定性。强烈建议在使用网络存储时启用此功能。

